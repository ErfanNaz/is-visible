{"mappings":"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","sources":["src/index.ts","src/add-observer.ts","src/utils.ts","src/remove-observer.ts"],"sourcesContent":["import { createAddClassObserver } from './add-observer';\nimport { createRemoveClassObserver } from './remove-observer';\n\nglobalThis.addEventListener(\n  'load',\n  () => {\n    createAddClassObserver();\n    createRemoveClassObserver();\n  },\n  false\n);\n","import {\n  defaultThreshold,\n  directiveElements,\n  generateThreshold,\n  getAttribute,\n  getOffset,\n} from './utils';\n\nconst directiveName = 'data-add-class';\nconst directiveAttributeName = 'addClass';\n\n/** a Set of all observed elements */\nconst observeElements = new Set<Element>();\n\nlet observer: IntersectionObserver;\n\n/**\n * will search for all elements with the given directive name [data-add-class] and add\n * obserable for the element to check if the element is visible\n * the user can control the offset with the additional [data-class-offset]\n */\nexport function createAddClassObserver() {\n  let elements = directiveElements(directiveName);\n\n  const threshold = generateThreshold(elements);\n\n  const options: IntersectionObserverInit = {\n    threshold: threshold,\n  };\n\n  observer = new IntersectionObserver(addClassHandler, options);\n  for (let element of elements) {\n    observeElements.add(element);\n    observer.observe(element);\n  }\n  if (observeElements.size <= 0) {\n    observer.disconnect();\n  }\n}\n\n/**\n * the add class handler will be called by the IntersectionObserver\n * everytime one of the observable elements will visible on the screen\n * @param entries\n * @param observer\n */\nfunction addClassHandler(\n  entries: IntersectionObserverEntry[],\n  observer: IntersectionObserver\n) {\n  for (let entrie of entries) {\n    let element = entrie.target;\n    const offset = getOffset(element) ?? defaultThreshold;\n    if (entrie.intersectionRatio >= offset) {\n      const className = getAttribute(element, directiveAttributeName);\n      if (className) {\n        element.classList.add(className);\n      }\n      unobserve(element);\n    }\n  }\n}\n\n/**\n * will trigger to no more observe the element\n * @param element\n */\nfunction unobserve(element: Element) {\n  observeElements.delete(element);\n  observer.unobserve(element);\n  if (observeElements.size <= 0) {\n    observer.disconnect();\n  }\n}\n","export const attributeNameClassOffset = 'classOffset';\n\nexport const defaultThreshold = 0.4;\n\nexport function directiveElements(directiveName: string) {\n  return globalThis.document.querySelectorAll(`[${directiveName}]`);\n}\n\nexport function getAttribute(element: Element, attrName: string) {\n  if (element instanceof HTMLElement) {\n    return element.dataset[attrName];\n  }\n  return null;\n}\n\n\nexport function getOffset(element: Element): number | null {\n  const offsetAsString = getAttribute(element, attributeNameClassOffset);\n  if (offsetAsString) {\n    return parseFloat(offsetAsString);\n  }\n  return null;\n}\n\nexport function generateThreshold(elements: NodeListOf<Element>): number[] | number {\n  let thresholdSet = new Set<number>();\n  for (let element of elements) {\n    const offset = getOffset(element);\n    if (offset) {\n      thresholdSet.add(offset);\n    }\n  }\n  if (thresholdSet.size > 0) {\n    return Array.from(thresholdSet);\n  }\n  return defaultThreshold;\n}\n","import {\n  defaultThreshold,\n  directiveElements,\n  generateThreshold,\n  getAttribute,\n  getOffset,\n} from './utils';\n\nconst directiveName = 'data-remove-class';\nconst directiveAttributeName = 'removeClass';\n\n/** a Set of all observed elements */\nconst observeElements = new Set<Element>();\n\nlet observer: IntersectionObserver;\n\n/**\n * will search for all elements with the given directive name [data-remove-class] and add\n * obserable for the element to check if the element is visible\n * the user can control the offset with the additional [data-class-offset]\n */\nexport function createRemoveClassObserver() {\n  let elements = directiveElements(directiveName);\n\n  const threshold = generateThreshold(elements);\n\n  const options: IntersectionObserverInit = {\n    threshold: threshold,\n  };\n\n  observer = new IntersectionObserver(removeClassHandler, options);\n  for (let element of elements) {\n    observeElements.add(element);\n    observer.observe(element);\n  }\n  if (observeElements.size <= 0) {\n    observer.disconnect();\n  }\n}\n\n/**\n * the remove class handler will be called by the IntersectionObserver\n * everytime one of the observable elements will visible on the screen\n * @param entries\n * @param observer\n */\nfunction removeClassHandler(\n  entries: IntersectionObserverEntry[],\n  observer: IntersectionObserver\n) {\n  for (let entrie of entries) {\n    let element = entrie.target;\n    const offset = getOffset(element) ?? defaultThreshold;\n    if (entrie.intersectionRatio >= offset) {\n      const className = getAttribute(element, directiveAttributeName);\n      if (className) {\n        element.classList.remove(className);\n      }\n      unobserve(element);\n    }\n  }\n}\n\n/**\n * will trigger to no more observe the element\n * @param element\n */\nfunction unobserve(element: Element) {\n  observeElements.delete(element);\n  observer.unobserve(element);\n  if (observeElements.size <= 0) {\n    observer.disconnect();\n  }\n}\n"],"names":[],"version":3,"file":"module.js.map"}