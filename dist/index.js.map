{"mappings":"AAIO,SAASA,EAAkBC,GAChC,OAAOC,WAAWC,SAASC,iBAAiB,IAAIH,K,CAG3C,SAASI,EAAaC,EAAkBC,GAC7C,OAAID,aAAmBE,YACdF,EAAQG,QAAQF,GAElB,I,CAIF,SAASG,EAAUJ,GACxB,MAAMK,EAAiBN,EAAaC,EAjBE,eAkBtC,OAAIK,EACKC,WAAWD,GAEb,I,CAGF,SAASE,EAAkBC,GAChC,IAAIC,EAAe,IAAIC,IACvB,IAAK,IAAIV,KAAWQ,EAAU,CAC5B,MAAMG,EAASP,EAAUJ,GACrBW,GACFF,EAAaG,IAAID,E,CAGrB,OAAIF,EAAaI,KAAO,EACfC,MAAMC,KAAKN,GA/BU,E,CCMhC,MAIMO,EAAkB,IAAIN,IAE5B,IAAIO,EAOG,SAASC,IACd,IAAIV,EAAWd,EAdK,kBAgBpB,MAAMyB,EAAYZ,EAAkBC,GAMpCS,EAAW,IAAIG,qBAAqBC,EAJM,CACxCF,UAAWA,IAIb,IAAK,IAAInB,KAAWQ,EAClBQ,EAAgBJ,IAAIZ,GACpBiB,EAASK,QAAQtB,GAEfgB,EAAgBH,MAAQ,GAC1BI,EAASM,Y,CAUb,SAASF,EACPG,EACAC,GAEA,IAAK,IAAIC,KAAUF,EAAS,CAC1B,IAAIxB,EAAU0B,EAAOC,OACrB,MAAMhB,EAASP,EAAUJ,IDlDG,GCmD5B,GAAI0B,EAAOE,mBAAqBjB,EAAQ,CACtC,MAAMkB,EAAY9B,EAAaC,EA7CN,YA8CrB6B,GACF7B,EAAQ8B,UAAUlB,IAAIiB,GAExBE,EAAU/B,E,GAShB,SAAS+B,EAAU/B,GACjBgB,EAAgBgB,OAAOhC,GACvBiB,EAASgB,UAAUjC,GACfgB,EAAgBH,MAAQ,GAC1BI,EAASM,Y,CC/Db,MAIMW,EAAkB,IAAIxB,IAE5B,IAAIyB,EAOG,SAASC,IACd,IAAI5B,EAAWd,EAdK,qBAgBpB,MAAMyB,EAAYZ,EAAkBC,GAMpC2B,EAAW,IAAIf,qBAAqBiB,EAJM,CACxClB,UAAWA,IAIb,IAAK,IAAInB,KAAWQ,EAClB0B,EAAgBtB,IAAIZ,GACpBmC,EAASb,QAAQtB,GAEfkC,EAAgBrB,MAAQ,GAC1BsB,EAASZ,Y,CAUb,SAASc,EACPb,EACAC,GAEA,IAAK,IAAIC,KAAUF,EAAS,CAC1B,IAAIxB,EAAU0B,EAAOC,OACrB,MAAMhB,EAASP,EAAUJ,IFlDG,GEmD5B,GAAI0B,EAAOE,mBAAqBjB,EAAQ,CACtC,MAAMkB,EAAY9B,EAAaC,EA7CN,eA8CrB6B,GACF7B,EAAQ8B,UAAUQ,OAAOT,GAE3BU,EAAUvC,E,GAShB,SAASuC,EAAUvC,GACjBkC,EAAgBF,OAAOhC,GACvBmC,EAASF,UAAUjC,GACfkC,EAAgBrB,MAAQ,GAC1BsB,EAASZ,Y,CCpEb3B,WAAW4C,iBACT,QACA,KACEtB,IACAkB,GAA2B,IAE7B","sources":["src/utils.ts","src/add-observer.ts","src/remove-observer.ts","src/index.ts"],"sourcesContent":["export const attributeNameClassOffset = 'classOffset';\n\nexport const defaultThreshold = 0.4;\n\nexport function directiveElements(directiveName: string) {\n  return globalThis.document.querySelectorAll(`[${directiveName}]`);\n}\n\nexport function getAttribute(element: Element, attrName: string) {\n  if (element instanceof HTMLElement) {\n    return element.dataset[attrName];\n  }\n  return null;\n}\n\n\nexport function getOffset(element: Element): number | null {\n  const offsetAsString = getAttribute(element, attributeNameClassOffset);\n  if (offsetAsString) {\n    return parseFloat(offsetAsString);\n  }\n  return null;\n}\n\nexport function generateThreshold(elements: NodeListOf<Element>): number[] | number {\n  let thresholdSet = new Set<number>();\n  for (let element of elements) {\n    const offset = getOffset(element);\n    if (offset) {\n      thresholdSet.add(offset);\n    }\n  }\n  if (thresholdSet.size > 0) {\n    return Array.from(thresholdSet);\n  }\n  return defaultThreshold;\n}\n","import {\n  defaultThreshold,\n  directiveElements,\n  generateThreshold,\n  getAttribute,\n  getOffset,\n} from './utils';\n\nconst directiveName = 'data-add-class';\nconst directiveAttributeName = 'addClass';\n\n/** a Set of all observed elements */\nconst observeElements = new Set<Element>();\n\nlet observer: IntersectionObserver;\n\n/**\n * will search for all elements with the given directive name [data-add-class] and add\n * obserable for the element to check if the element is visible\n * the user can control the offset with the additional [data-class-offset]\n */\nexport function createAddClassObserver() {\n  let elements = directiveElements(directiveName);\n\n  const threshold = generateThreshold(elements);\n\n  const options: IntersectionObserverInit = {\n    threshold: threshold,\n  };\n\n  observer = new IntersectionObserver(addClassHandler, options);\n  for (let element of elements) {\n    observeElements.add(element);\n    observer.observe(element);\n  }\n  if (observeElements.size <= 0) {\n    observer.disconnect();\n  }\n}\n\n/**\n * the add class handler will be called by the IntersectionObserver\n * everytime one of the observable elements will visible on the screen\n * @param entries\n * @param observer\n */\nfunction addClassHandler(\n  entries: IntersectionObserverEntry[],\n  observer: IntersectionObserver\n) {\n  for (let entrie of entries) {\n    let element = entrie.target;\n    const offset = getOffset(element) ?? defaultThreshold;\n    if (entrie.intersectionRatio >= offset) {\n      const className = getAttribute(element, directiveAttributeName);\n      if (className) {\n        element.classList.add(className);\n      }\n      unobserve(element);\n    }\n  }\n}\n\n/**\n * will trigger to no more observe the element\n * @param element\n */\nfunction unobserve(element: Element) {\n  observeElements.delete(element);\n  observer.unobserve(element);\n  if (observeElements.size <= 0) {\n    observer.disconnect();\n  }\n}\n","import {\n  defaultThreshold,\n  directiveElements,\n  generateThreshold,\n  getAttribute,\n  getOffset,\n} from './utils';\n\nconst directiveName = 'data-remove-class';\nconst directiveAttributeName = 'removeClass';\n\n/** a Set of all observed elements */\nconst observeElements = new Set<Element>();\n\nlet observer: IntersectionObserver;\n\n/**\n * will search for all elements with the given directive name [data-remove-class] and add\n * obserable for the element to check if the element is visible\n * the user can control the offset with the additional [data-class-offset]\n */\nexport function createRemoveClassObserver() {\n  let elements = directiveElements(directiveName);\n\n  const threshold = generateThreshold(elements);\n\n  const options: IntersectionObserverInit = {\n    threshold: threshold,\n  };\n\n  observer = new IntersectionObserver(removeClassHandler, options);\n  for (let element of elements) {\n    observeElements.add(element);\n    observer.observe(element);\n  }\n  if (observeElements.size <= 0) {\n    observer.disconnect();\n  }\n}\n\n/**\n * the remove class handler will be called by the IntersectionObserver\n * everytime one of the observable elements will visible on the screen\n * @param entries\n * @param observer\n */\nfunction removeClassHandler(\n  entries: IntersectionObserverEntry[],\n  observer: IntersectionObserver\n) {\n  for (let entrie of entries) {\n    let element = entrie.target;\n    const offset = getOffset(element) ?? defaultThreshold;\n    if (entrie.intersectionRatio >= offset) {\n      const className = getAttribute(element, directiveAttributeName);\n      if (className) {\n        element.classList.remove(className);\n      }\n      unobserve(element);\n    }\n  }\n}\n\n/**\n * will trigger to no more observe the element\n * @param element\n */\nfunction unobserve(element: Element) {\n  observeElements.delete(element);\n  observer.unobserve(element);\n  if (observeElements.size <= 0) {\n    observer.disconnect();\n  }\n}\n","import { createAddClassObserver } from './add-observer';\nimport { createRemoveClassObserver } from './remove-observer';\n\nglobalThis.addEventListener(\n  'load',\n  () => {\n    createAddClassObserver();\n    createRemoveClassObserver();\n  },\n  false\n);\n"],"names":["$533342404bccfdc5$export$969779b29dcce574","directiveName","globalThis","document","querySelectorAll","$533342404bccfdc5$export$735ee1799fd02602","element","attrName","HTMLElement","dataset","$533342404bccfdc5$export$622cea445a1c5b7d","offsetAsString","parseFloat","$533342404bccfdc5$export$e9996d7558cf08bb","elements","thresholdSet","Set","offset","add","size","Array","from","$a4901b3e35a2adce$var$observeElements","$a4901b3e35a2adce$var$observer","$a4901b3e35a2adce$export$89864446d30c3dc9","threshold","IntersectionObserver","$a4901b3e35a2adce$var$addClassHandler","observe","disconnect","entries","observer","entrie","target","intersectionRatio","className","classList","$a4901b3e35a2adce$var$unobserve","delete","unobserve","$f21bb3558ae0ca5e$var$observeElements","$f21bb3558ae0ca5e$var$observer","$f21bb3558ae0ca5e$export$4d169348e4e381a8","$f21bb3558ae0ca5e$var$removeClassHandler","remove","$f21bb3558ae0ca5e$var$unobserve","addEventListener"],"version":3,"file":"index.js.map"}